<!doctype html>
<html lang="en">
<head>
	<title>Reflection (Three.js) Example 04 05</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="three.js"></script>
<script src="ParametricGeometries.js"></script>
<script src="CurveExtras.js"></script>
<script src="Detector.js"></script>
<script src="stats.js"></script>
<script src="OrbitControls.js"></script>
<script src="THREEx.KeyboardState.js"></script>
<script src="THREEx.FullScreen.js"></script>
<script src="THREEx.WindowResize.js"></script>


<!-- jQuery code to display an information button and box when clicked. -->
<script src="jquery-1.9.1.js"></script>
<script src="jquery-ui.js"></script>
<link rel=stylesheet href="jquery-ui.css" />
<link rel=stylesheet href="info.css"/>
<script src="info.js"></script>
<script src="GLTFLoader.js"></script>
<div id="infoButton"></div>
<div id="infoBox" title="Demo Information">
This three.js demo is part of a collection at
<a href="http://stemkoski.github.io/Three.js/">http://stemkoski.github.io/Three.js/</a>
</div>
<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>

class MirrorShape {
	constructor(shape, camera) {
		this.shape = shape;
		this.camera = camera;
	}

}


// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var mirrorCube
var planetMercury, planetVenus, planetEarth,planetMoon, planetMars, planetJupiter,planetSaturn, planetUranus, planetNeptune,planetSun
var mirrorSphere
var box
var orbitingSpheres =[]
var planets = []
var moonPivot

init();
animate();




// FUNCTIONS 		
function init() 
{


	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	// camera.position.set(0,150,400);
	camera.position.set(3000,3000,500);
	camera.layers.enable(2)
	// camera.layers.set(2)

	camera.lookAt(scene.position);	
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,0,0);
	// light.layers.set(1)
	scene.add(light);

	var ambientLight = new THREE.AmbientLight( 0xffffff);
	ambientLight.layers.set(2);
	scene.add( ambientLight );

	// var light = new THREE.PointLight(0xffffff);
	// light.position.set(0,2700,0);
	// light.layers.set(2);
	// scene.add(light);
	//
	// var light = new THREE.PointLight(0xffffff);
	// light.position.set(0,-2700,0);
	// light.layers.set(2);
	// scene.add(light);

	// var light = new THREE.PointLight(0xffffff);
	// light.position.set(0,0,0);
	// scene.add(light);
	//
	// var light = new THREE.PointLight(0xffffff);
	// light.position.set(0,0,0);
	// scene.add(light);
	// FLOOR

	
	// SKYBOX/FOG
	var materialArray = [];
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/2k_stars.jpg' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/2k_stars.jpg' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/2k_stars.jpg' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/2k_stars_milky_way.jpg' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/2k_stars.jpg' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/2k_stars.jpg' ) }));
	for (var i = 0; i < 6; i++)
	   materialArray[i].side = THREE.BackSide;
	var skyboxMaterial = new THREE.MeshFaceMaterial( materialArray );
	var skyboxGeom = new THREE.BoxGeometry( 9000, 9000, 9000, 64, 64, 64 );
	var skybox = new THREE.Mesh( skyboxGeom, skyboxMaterial );
	scene.add( skybox );


	var axes = new THREE.AxisHelper(2000);
	scene.add( axes );
	///////////////////////////////////CUSTOM//////////////////////////////////////////

	planetSun = generateSun("2k_sun.jpg",null,0,0,0,450)
	planetSun.opacity =50
	planetSun.transparent = true
	planetSun.layers.set(2)
	planetSun.name="sun"

	planetMercury = generatePlanet("2k_mercury.jpg",null,800,0,800,38)
	planetVenus = generatePlanet("2k_venus_surface.jpg","2k_venus_atmosphere.jpg",1000,0,1000,94)

	planetEarth = generatePlanet("2k_earth_daymap.jpg","2k-earth_normal_map.tif",-1200,0,-1200,100)
	planetMoon = generatePlanet("2k_moon.jpg","null",100,0,700)

	moonPivot = new THREE.Object3D();
	moonPivot.position = planetEarth.position;
	planetEarth.add( moonPivot );
	moonPivot.add(planetMoon)
	planetMoon.name="moon"
	// planetMoon.position = planetEarth.position


	planetMars = generatePlanet("2k_mars.jpg","null",-1350,0,-1350,53)
	planetJupiter = generatePlanet("2k_jupiter.jpg",null,1800,0,1800,330)

	planetSaturn = generatePlanet("2k_saturn.jpg",null,2200,0,2200,230)
	planetUranus = generatePlanet("2k_uranus.jpg",null,2470,0,2470,200)
	planetNeptune = generatePlanet("2k_neptune.jpg",null,2670,0,6470,176)

	// var loader = new THREE.GLTFLoader();
	// loader.load( 'sun/sun.gltf', function ( gltf ) {           //   <<--------- Model Path
	// 	planetSun = gltf.scene;
	// 	planetSun.layers.set(2)
	// 	gltf.scene.scale.set( 1700, 1700, 1700 );
	// 	gltf.scene.position.x = 0;				    //Position (x = right+ left-)
	// 	gltf.scene.position.y = 0;				    //Position (y = up+, down-)
	// 	gltf.scene.position.z = 0;				    //Position (z = front +, back-)
	// 	//gltf.animations;
	// 	scene.add( gltf.scene );
	// });




	// mirrorCube = generateMirrorCube()
	// mirrorSphere = generateMirrorSphere(50,75,50,0)

	// var radius = 400
	// var a = Math.floor(0.5 *radius)
	// var b = Math.floor(0.5*radius*Math.sqrt(3))
	// orbitingSpheres[0] = generateMirrorSphere(50,0,50,radius)
	// orbitingSpheres[1] = generateMirrorSphere(50,b,50,-a)
	// orbitingSpheres[2] = generateMirrorSphere(50,-b,50,-a)

	// "2k_earth_daymap.jpg","2k-earth_normal_map.tif"




}

function generateSun(texture, normal,x,y,z,size=75){
	var sphereGeom =new THREE.SphereGeometry(size, 20,20)
	var sphere = createBumpMesh(sphereGeom, texture,normal);
// var sphere = createBumpMesh(new THREE.CubeGeometry(size, size, size,1,1,1), "stone.jpg","brick-wall.jpg");
	sphere.position.set(x,y,z);
	sphere.rotation.x=Math.PI/2  +Math.PI*0.2;
	scene.add(sphere);
	planets.push(sphere)
	return sphere
}


function generatePlanet(texture, normal,x,y,z,size=75){
	var sphereGeom =new THREE.SphereGeometry(size, 20,20)
	var sphere = createBumpMesh(sphereGeom, texture,normal);
// var sphere = createBumpMesh(new THREE.CubeGeometry(size, size, size,1,1,1), "stone.jpg","brick-wall.jpg");
	sphere.position.set(x,y,z);
	sphere.rotation.x=Math.PI/2  +Math.PI*0.2;
	sphere.castShadow=true
	sphere.receiveShadow =true
	scene.add(sphere);

	planets.push(sphere)
	return sphere
}


function generateMirrorSphere(radius,x,y,z) {
	var sphereGeom =  new THREE.SphereGeometry( radius, 32, 16); // radius, segmentsWidth, segmentsHeight
	var mirrorCamera = new THREE.CubeCamera( 0.1, 5000, 512 );
	scene.add( mirrorCamera );
	var mirrorSphereMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorCamera.renderTarget } );
	var mirrorSphere = new THREE.Mesh( sphereGeom, mirrorSphereMaterial );
	mirrorSphere.position.set(x,y,z);
	mirrorCamera.position = mirrorSphere.position;
	scene.add(mirrorSphere);

	return new MirrorShape(mirrorSphere,mirrorCamera)

}

function generateMirrorCube() {
	var cubeGeom = new THREE.CubeGeometry(200, 200, 30,1,1,1);
	var mirrorCubeCamera = new THREE.CubeCamera( 0.1, 5000, 512 );
	scene.add( mirrorCubeCamera );
	var mirrorCubeMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorCubeCamera.renderTarget } );
	var mirrorCube = new THREE.Mesh( cubeGeom, mirrorCubeMaterial );
	mirrorCube.position.set(-75,50,0);
//mirrorCubeCamera.position = mirrorCube.position;    not working with new three.js
	mirrorCubeCamera.position.set(-75,50,0);
	scene.add(mirrorCube);
	return new MirrorShape(mirrorCube,mirrorCubeCamera)

}


function rotateObject(object,rotSpeed =0.01) {
	var x = object.position.x;
	var z = object.position.z;

	object.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
	object.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);

}






function createNormalMesh(geom, imageFile, normal) {
	var t = THREE.ImageUtils.loadTexture("textures/" + imageFile);
	var m = THREE.ImageUtils.loadTexture("textures/" + normal);
	var mat2 = new THREE.MeshPhongMaterial({
		map: t, normalMap: m
	});
	var mesh = new THREE.Mesh(geom, mat2);
	return mesh;
}

function createBumpMesh(geom, imageFile, bump) {
	var texture = THREE.ImageUtils.loadTexture("textures/" + imageFile)
	geom.computeVertexNormals();
	var mat = new THREE.MeshPhongMaterial();
	mat.map = texture;

	if (bump) {
		var bump = THREE.ImageUtils.loadTexture("textures/" + bump)
		mat.bumpMap = bump;
		mat.bumpScale = 0.2;
		console.log('d');
	}
	// create a multimaterial
	var mesh = new THREE.Mesh(geom, mat);

	return mesh;
}

function makeMirrorEffect(object){
	// move the CubeCamera to the position of the object
	//    that has a reflective surface, "take a picture" in each direction
	//    and apply it to the surface.
	// need to hide surface before and after so that it does not
	//    "get in the way" of the camera
	var shape =object.shape
	var camera = object.camera
	shape.visible = false;
	camera.updateCubeMap( renderer, scene );
	shape.visible = true;
}

function animate() 
{
	requestAnimationFrame( animate );

	controls.update();
	renderer.autoClear = true;
	camera.layers.set(0); // << == switch camera between layers
	renderer.render(scene, camera);

	renderer.autoClear = false; // don't remove previous layer results

	camera.layers.set(2); // << == switch camera between layers
	renderer.render(scene, camera);



	render();
	// update();
}

// function update()
// {
// 	if ( keyboard.pressed("z") )
// 	{
// 		// do something
// 	}
//
// 	controls.update();
// 	stats.update();
// }

function render()
{
	// animateStars();
	rotateObject(planetMercury,0.006)
	rotateObject(planetVenus,0.007)
	rotateObject(planetEarth,0.004)
	rotateObject(planetMars,0.01)
	rotateObject(planetJupiter,0.001)

	rotateObject(planetSaturn,0.003)
	rotateObject(planetUranus,0.005)
	rotateObject(planetNeptune,0.0009)
	// planets[i].name
	for(var i=0;i< planets.length;i++){
		if((planets[i].name.localeCompare("sun"))==0){

			planets[i].rotation.y +=0.01;
			continue
		}else if((planets[i].name.localeCompare("moon"))==0){

			// planets[i].rotation.y +=0.003;
			continue
		}
		planets[i].rotation.y +=0.05;
	}
	//plantes[4] =moon
	// moonPivot.rotation+=0.1
	planets[1].rotation.y -=1.4;
	planets[3].rotation.y +=0.1;
	planets[6].rotation.y -=0.6;
	planets[5].rotation.y +=0.3;




	// rotateObject(planetMars)

	// makeMirrorEffect(mirrorCube)
	// makeMirrorEffect(mirrorSphere)

	// rotateObject(mirrorSphere)
	//
	// orbitingSpheres.forEach(function (sphere, index) {
	// 	makeMirrorEffect(sphere)
	// 	rotateObject(sphere)
	//
	// });




	// renderer.render( scene, camera );
}

</script>

</body>
</html>
